# 1.模块化、组件化、插件化
1. 模块化
   - 根据不同的关注点，将一个项目的可以共享的部分抽取出来，形成独立的Module，这就是模块化。模块化不只包含公共部分，当然也可以
   是业务模块。比如：图片加载模块。
2. <font color=red size=5>**组件化**</font>
   - 组件化是建立在模块化思想上的一次演进，一个变种。组件化本来就是模块化的概念。核心是模块角色的可转化换性，<font color=red>**在打包时，是library；
   调试时，是application。**</font>组件化的单位是组件。
3. 插件化
   - 严格意义来讲，其实也算是模块化的观念。将一个完整的工程，按业务划分为不同的插件，来化整为零，相互配合。`插件化的单位是apk(一个完成的应用)。`
   可以实现apk 的动态加载，动态更新，比组件化更灵活。

# 2.<font color=red>Gradle组件化配置</font>
1. gradle简介和对应文件说明
   - 简介: gradle 是一个构建工具。负责管理项目依赖，组织项目结构，完成项目构建的工作。基于Groovy语言
   （Groovy是一种基于JVM的敏捷开发语言，可以简单的理解为强类型语言java的弱类型版本）。
   - build.gradle：构建脚本文件，主要的构建配置都在这里写
   - gradle文件夹：存放gradle wrapper 执行配置和工具的文件夹
   - gradlew：gradle wrapper 执行脚本文件，用来在没有安装 gradle 的情况下执行 gradle 命令。当然，第一次执行时会下载 gradle。
   - gradlew.bat：gradle wrapper 执行脚本文件的 windows 版
   - settings.gradle：项目配置，指明根项目名字和引入的 module
2. <font color=red size = 5>**组件化配置**</font>
   1. 项目根目录下新建`config.gradle`文件
      ```
        ext{ //extend
            // false：组件模式
            // true：集成模式
            isModule = true
            android = [
                    compileSdkVersion: 29,
                    minSdkVersion:16,
                    targetSdkVersion:29,
                    versionCode:1,
                    versionName:"1.0"
            ]
        
            appId = [
                    app:"com.dn_alan.myapplication",
                    module1:"com.dn_alan.module1",
                    module2:"com.dn_alan.module2"
            ]
        
            supportLibrary = "28.0.0"
            dependencies = [
                    "appcompat-v7":"com.android.support:appcompat-v7:$supportLibrary"  // key为什么要加引号是因为有特殊字符-
            ]
        }     
      ```
   2. 项目的 `build.gradle` 中依赖config.gradle
      ```
      //相当于引入头文件 将 config中的内容引入进来
      apply from: "config.gradle"
      buildscript {
          repositories {
              ...    
          }
          dependencies {
              ...    
          }    
      }
      ...     
      ```
   3. `app`级的build.gradle中配置
      ```
        apply plugin: 'com.android.application'
        
        //赋值与引用
        def cfg = rootProject.ext.android
        def appId = rootProject.ext.appId
        android {
            compileSdkVersion cfg.compileSdkVersion
            defaultConfig {
                applicationId appId["app"] // 也可以appid.app
                minSdkVersion cfg.minSdkVersion
                targetSdkVersion cfg.targetSdkVersion
                versionCode cfg.versionCode
                versionName cfg.versionName
                testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        
                javaCompileOptions {
                    annotationProcessorOptions {
                        arguments = [moduleName: project.getName()]
                    }
                }
            }
            ...
        }
        
        dependencies {
            ...
            annotationProcessor project(':router_compiler')
            implementation project(':base')

            if (isModule){ // 如果是打包的情况下，就依赖module1和moudle2
                implementation project(':module2')
                implementation project(':module1')
            }        
        }      
      ```
   4. `moudle2`的build.gradle中的配置
      ```
        //根据isModule标签动态的切换 集成/组件模式
        if (isModule){
            apply plugin: 'com.android.library'
        }else{
            apply plugin: 'com.android.application'
        }
        
        def cfg = rootProject.ext.android
        def appId = rootProject.ext.appId
        
        android {
            compileSdkVersion cfg.compileSdkVersion
        
            defaultConfig {
                minSdkVersion cfg.minSdkVersion
                targetSdkVersion cfg.targetSdkVersion
                versionCode cfg.versionCode
                versionName cfg.versionName
        
                testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        
                javaCompileOptions {
                    annotationProcessorOptions {
                        arguments = [ moduleName : project.getName() ]
                    }
                }
        
                //添加一条 boolean类型的变量
                buildConfigField("boolean","isModule",String.valueOf(isModule))
        
                //组件模式下,设置moudle的appid
                if (!isModule){
                    applicationId appId['module2']
                }
        
                //资源配置
                sourceSets{
                    main{
                        //在组件模式下 使用不同的manifest文件
                        if(!isModule){
                            manifest.srcFile 'src/main/module/AndroidManifest.xml'
                            java.srcDirs 'src/main/module/java','src/main/java'
        
                        }else{
                            manifest.srcFile 'src/main/AndroidManifest.xml'
                        }
                    }
                }
        
            }
        
            buildTypes {
                ...
            }
        
        }
        
        dependencies {
            ...        
            annotationProcessor project(':router_compiler')
            implementation project(':base')
        }      
      ```

# 3. Arouter路由原理
![](../images/路由原理.png)

# 4. <font color=red>自定义注解处理器</font>
1. AnnotationProcessor
   - Annotation Processor是javac的一个工具，它用来在编译时扫描和处理注解。通过Annotation Processor可以获取到注解和被注解对
   象的相关信息，然后根据注解自动生成Java代码，省去了手动编写，提高了编码效率。
   - ![](../images/编译器原理.png)
   - 刚接触Annotation Processor的同学可能会遇到找不到AbstractProcessor类的问题，大概率是因为直接在Android项目里边引用了
   AbstractProcessor，然而由于Android平台是基于OpenJDK的，而OpenJDK中不包含Annotation Processor的相关代码。因此，**在使用
   Annotation Processor时，必须在新建Module时选择`Java Library`**，处理注解相关的代码都需要在Java Library模块下完成。我们
   需要看一下整个项目的结构
   - ![](../images/自定义注解处理器的项目结构.png)
2. <font color=red size = 5>**步骤**</font>
   1. 新建`Java Library：router_annotation` 用于存放所有的注解
   2. 新建`Java Library：router_compiler` 注解处理类
      1. 看下router_compiler的build.gradle文件
         - 依赖`router_annotation`
         - 添加`auto-service`依赖：注册注解处理器，指定的注解都会在`RouteProcessor`中处理
         - 添加[javapoet](https://github.com/square/javapoet)依赖：用于生成代码
         ```
            apply plugin: 'java-library'
            
            dependencies {
                implementation fileTree(dir: 'libs', include: ['*.jar'])
            
                annotationProcessor 'com.google.auto.service:auto-service:1.0-rc4'
                compileOnly 'com.google.auto.service:auto-service:1.0-rc4'
            
                implementation 'com.squareup:javapoet:1.11.1'
            
                implementation project(':router_annotation')
            }
            
            // java控制台输出中文乱码
            tasks.withType(JavaCompile) {
                options.encoding = "UTF-8"
            }
            
            sourceCompatibility = "7"
            targetCompatibility = "7"          
         ```
      2. 新建`RouteProcessor.java`继承自AbstractProcessor
         ```
            /**
             * 在这个类上添加了@AutoService注解，它的作用是用来生成
             * META-INF/services/javax.annotation.processing.Processor文件的，
             * 也就是我们在使用注解处理器的时候需要手动添加
             * META-INF/services/javax.annotation.processing.Processor，
             * 而有了@AutoService后它会自动帮我们生成。
             * AutoService是Google开发的一个库，使用时需要在
             * factory-compiler中添加依赖
             */
            @AutoService(Processor.class)   //注册注解处理器
            /**
             * 处理器接收的参数 替代 {@link AbstractProcessor#getSupportedOptions()} 函数
             */
            @SupportedOptions(Consts.ARGUMENTS_NAME)
            /**
             * 指定使用的Java版本 替代 {@link AbstractProcessor#getSupportedSourceVersion()} 函数
             * 声明我们注解支持的JDK的版本
             */
            @SupportedSourceVersion(SourceVersion.RELEASE_7)
            /**
             * 注册给哪些注解的  替代 {@link AbstractProcessor#getSupportedAnnotationTypes()} 函数
             * 声明我们要处理哪一些注解 该方法返回字符串的集合表示该处理器用于处理哪些注解
             */
            @SupportedAnnotationTypes({Consts.ANN_TYPE_ROUTE})
            public class RouteProcessor extends AbstractProcessor {
            
            
                /**
                 * key:组名 value:类名
                 */
                private Map<String, String> rootMap = new TreeMap<>();
                /**
                 * 分组 key:组名 value:对应组的路由信息
                 */
                private Map<String, List<RouteMeta>> groupMap = new HashMap<>();
                /**
                 * 节点工具类 (类、函数、属性都是节点)
                 */
                private Elements elementUtils;
            
                /**
                 * type(类信息)工具类
                 */
                private Types typeUtils;
                /**
                 * 文件生成器 类/资源
                 */
                private Filer filerUtils;
                /**
                 * 参数
                 */
                private String moduleName;
            
                private Log log;
            
                /**
                 * 初始化 从 {@link ProcessingEnvironment} 中获得一系列处理器工具
                 *
                 * @param processingEnvironment
                 */
                @Override
                public synchronized void init(ProcessingEnvironment processingEnvironment) {
                    super.init(processingEnvironment);
                    //获得apt的日志输出
                    log = Log.newLog(processingEnvironment.getMessager());
                    log.i("init()");
                    elementUtils = processingEnv.getElementUtils();
                    typeUtils = processingEnvironment.getTypeUtils();
                    filerUtils = processingEnv.getFiler();
                    //参数是模块名 为了防止多模块/组件化开发的时候 生成相同的 xx$$ROOT$$文件
                    Map<String, String> options = processingEnv.getOptions();
                    if (!Utils.isEmpty(options)) {
                        moduleName = options.get(Consts.ARGUMENTS_NAME);
                    }
                    log.i("RouteProcessor Parmaters:" + moduleName);
                    if (Utils.isEmpty(moduleName)) {
                        throw new RuntimeException("Not set Processor Parmaters.");
                    }
                }
            
                /**
                 * 相当于main函数，正式处理注解
                 *
                 * @param set 使用了支持处理注解  的节点集合
                 * @param roundEnvironment 表示当前或是之前的运行环境,可以通过该对象查找找到的注解。
                 * @return true 表示后续处理器不会再处理(已经处理)
                 */
                @Override
                public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
            
                    //使用了需要处理的注解
                    if (!Utils.isEmpty(set)) {
                        //获取所有被 Route 注解的元素集合
                        Set<? extends Element> routeElements = roundEnvironment.getElementsAnnotatedWith
                                (Route.class);
                        //处理 Route 注解
                        if (!Utils.isEmpty(routeElements)) {
                            try {
                                log.i("Route Class: ===" + routeElements.size());
                                parseRoutes(routeElements);
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                        return true;
                    }
                    return false;
                }
            
                private void parseRoutes(Set<? extends Element> routeElements) throws IOException {
                    //支持配置路由类的类型
                    TypeElement activity = elementUtils.getTypeElement(Consts.ACTIVITY);
                    //节点自描述 Mirror
                    TypeMirror type_Activity = activity.asType();
                    log.i("Route Class: ===" + type_Activity);
                    TypeElement iService = elementUtils.getTypeElement(Consts.ISERVICE);
                    TypeMirror type_IService = iService.asType();
            
            
                    /**
                     * groupMap(组名:路由信息)集合
                     */
                    //声明 Route 注解的节点 (需要处理的节点 Activity/IService)
                    for (Element element : routeElements) {
                        //路由信息
                        RouteMeta routeMeta;
                        // 使用Route注解的类信息
                        TypeMirror tm = element.asType();
                        log.i("Route Class: " + tm.toString());
                        Route route = element.getAnnotation(Route.class);
                        //是否是 Activity 使用了Route注解
                        if (typeUtils.isSubtype(tm, type_Activity)) {
                            routeMeta = new RouteMeta(RouteMeta.Type.ACTIVITY, route, element);
                        } else if (typeUtils.isSubtype(tm, type_IService)) {
                            routeMeta = new RouteMeta(RouteMeta.Type.ISERVICE, route, element);
                        } else {
                            throw new RuntimeException("[Just Support Activity/IService Route] :" + element);
                        }
                        //分组信息记录  groupMap <Group分组,RouteMeta路由信息> 集合
                        categories(routeMeta);
                    }
            
                   //生成类需要实现的接口
                    TypeElement iRouteGroup = elementUtils.getTypeElement(Consts.IROUTE_GROUP);
                    log.i("---------" + iRouteGroup.getSimpleName());
                    TypeElement iRouteRoot = elementUtils.getTypeElement(Consts.IROUTE_ROOT);
            
                    /**
                     *  生成Group类 作用:记录 <地址,RouteMeta路由信息(Class文件等信息)>
                     */
                    generatedGroup(iRouteGroup);
                    /**
                     * 生成Root类 作用:记录 <分组，对应的Group类>
                     */
                    generatedRoot(iRouteRoot, iRouteGroup);
            
            
                }
            
                private void generatedGroup(TypeElement iRouteGroup) throws IOException {
                    //参数  Map<String,RouteMeta>
                    ParameterizedTypeName atlas = ParameterizedTypeName.get(
                            ClassName.get(Map.class),
                            ClassName.get(String.class),
                            ClassName.get(RouteMeta.class)
                    );
                    //参数 Map<String,RouteMeta> atlas
                    ParameterSpec groupParamSpec = ParameterSpec.builder(atlas, "atlas")
                            .build();
            
                    //遍历分组,每一个分组创建一个 $$Group$$ 类
                    for (Map.Entry<String, List<RouteMeta>> entry : groupMap.entrySet()) {
                        /**
                         * 类成员函数loadInfo声明构建
                         */
                        //函数 public void loadInfo(Map<String,RouteMeta> atlas)
                        MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder
                                (Consts.METHOD_LOAD_INTO)
                                .addAnnotation(Override.class)
                                .addModifiers(PUBLIC)
                                .addParameter(groupParamSpec);
            
                        //分组名 与 对应分组中的信息
                        String groupName = entry.getKey();
                        List<RouteMeta> groupData = entry.getValue();
                        //遍历分组中的条目 数据
                        for (RouteMeta routeMeta : groupData) {
                            // 组装函数体:
                            // atlas.put(地址,RouteMeta.build(Class,path,group))
                            // $S https://github.com/square/javapoet#s-for-strings
                            // $T https://github.com/square/javapoet#t-for-types
                            loadIntoMethodOfGroupBuilder.addStatement(
                                    "atlas.put($S, $T.build($T.$L,$T.class, $S, $S))",
                                    routeMeta.getPath(),
                                    ClassName.get(RouteMeta.class),
                                    ClassName.get(RouteMeta.Type.class),
                                    routeMeta.getType(),
                                    ClassName.get((TypeElement) routeMeta.getElement()),
                                    routeMeta.getPath().toLowerCase(),
                                    routeMeta.getGroup().toLowerCase());
                        }
                        // 创建java文件($$Group$$)  组
                        String groupClassName = Consts.NAME_OF_GROUP + groupName;
                        JavaFile.builder(Consts.PACKAGE_OF_GENERATE_FILE,
                                TypeSpec.classBuilder(groupClassName)
                                        .addSuperinterface(ClassName.get(iRouteGroup))
                                        .addModifiers(PUBLIC)
                                        .addMethod(loadIntoMethodOfGroupBuilder.build())
                                        .build()
                        ).build().writeTo(filerUtils);
                        log.i("Generated RouteGroup: " + Consts.PACKAGE_OF_GENERATE_FILE + "." +
                                groupClassName);
                        //分组名和生成的对应的Group类类名
                        rootMap.put(groupName, groupClassName);
                    }
                }
            
                private void generatedRoot(TypeElement iRouteRoot, TypeElement iRouteGroup) throws IOException {
                    //类型 Map<String,Class<? extends IRouteGroup>> routes>
                    //Wildcard 通配符
                    ParameterizedTypeName routes = ParameterizedTypeName.get(
                            ClassName.get(Map.class),
                            ClassName.get(String.class),
                            ParameterizedTypeName.get(
                                    ClassName.get(Class.class),
                                    WildcardTypeName.subtypeOf(ClassName.get(iRouteGroup))
                            )
                    );
            
                    //参数 Map<String,Class<? extends IRouteGroup>> routes> routes
                    ParameterSpec rootParamSpec = ParameterSpec.builder(routes, "routes")
                            .build();
                    //函数 public void loadInfo(Map<String,Class<? extends IRouteGroup>> routes> routes)
                    MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder
                            (Consts.METHOD_LOAD_INTO)
                            .addAnnotation(Override.class)
                            .addModifiers(PUBLIC)
                            .addParameter(rootParamSpec);
            
                    //函数体
                    for (Map.Entry<String, String> entry : rootMap.entrySet()) {
                        loadIntoMethodOfRootBuilder.addStatement("routes.put($S, $T.class)", entry
                                .getKey(), ClassName.get(Consts.PACKAGE_OF_GENERATE_FILE, entry.getValue
                                ()));
                    }
                    //生成 $Root$类
                    String rootClassName = Consts.NAME_OF_ROOT + moduleName;
                    JavaFile.builder(Consts.PACKAGE_OF_GENERATE_FILE,
                            TypeSpec.classBuilder(rootClassName)
                                    .addSuperinterface(ClassName.get(iRouteRoot))
                                    .addModifiers(PUBLIC)
                                    .addMethod(loadIntoMethodOfRootBuilder.build())
                                    .build()
                    ).build().writeTo(filerUtils);
            
                    log.i("Generated RouteRoot: " + Consts.PACKAGE_OF_GENERATE_FILE + "." + rootClassName);
                }
            
                private void categories(RouteMeta routeMeta) {
                    if (routeVerify(routeMeta)) {
                        log.i("Group Info, Group Name = " + routeMeta.getGroup() + ", Path = " +
                                routeMeta.getPath());
                        List<RouteMeta> routeMetas = groupMap.get(routeMeta.getGroup());
                        //如果未记录分组则创建
                        if (Utils.isEmpty(routeMetas)) {
                            List<RouteMeta> routeMetaSet = new ArrayList<>();
                            routeMetaSet.add(routeMeta);
                            groupMap.put(routeMeta.getGroup(), routeMetaSet);
                        } else {
                            routeMetas.add(routeMeta);
                        }
                    } else {
                        log.i("Group Info Error: " + routeMeta.getPath());
                    }
                }
            
                /**
                 * 验证路由信息必须存在path(并且设置分组)
                 *
                 * @param meta raw meta
                 */
                private boolean routeVerify(RouteMeta meta) {
                    String path = meta.getPath();
                    String group = meta.getGroup();
                    //路由地址必须以 / 开头
                    if (Utils.isEmpty(path) || !path.startsWith("/")) {
                        return false;
                    }
                    //如果没有设置分组,以第一个 / 后的节点为分组(所以必须path两个/)
                    if (Utils.isEmpty(group)) {
                        String defaultGroup = path.substring(1, path.indexOf("/", 1));
                        if (Utils.isEmpty(defaultGroup)) {
                            return false;
                        }
                        meta.setGroup(defaultGroup);
                        return true;
                    }
                    return true;
                }
            
            }         
         ```



